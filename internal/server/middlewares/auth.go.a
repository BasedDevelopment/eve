package middlewares

import "net/http"

func AdminAuth(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		if strings.HasPrefix(r.Header.Get("Auth-Token"), "v1") {
		token, err := parseToken(r.Header.Get("Auth-Token"))

		if err != nil {
			w.WriteHeader(http.StatusBadRequest)
			w.Write([]byte("parsing auth token errored. is it valid?"))
		}

		entry := rdb.Get(ctx, token.Public).String()

		if entry != "" {
			entryToken, err := parseToken(entry)

			if err != nil {
				w.WriteHeader(http.StatusBadRequest)
				w.Write([]byte("parsing auth token in database errored. is it valid?"))
			}

			unb64dSecret, err := base64.URLEncoding.DecodeString(token.Secret)

			if err != nil {
				w.WriteHeader(http.StatusInternalServerError)
				w.Write([]byte("problem decoding secret from base64"))
				w.Write([]byte(err.Error()))
			}

			buf := []byte(string(unb64dSecret) + token.Salt)
			secret := make([]byte, 64)
			sha3.ShakeSum256(secret, buf)

			if subtle.ConstantTimeCompare(
				[]byte(entryToken.Secret),         // secret from the database (already in hex)
				[]byte(fmt.Sprintf("%x", secret)), // secret from the request (now salted & hashed, and converted to hex)
			) == 1 { // we are authenticated
				w.WriteHeader(http.StatusOK)
				w.Write([]byte("welcome"))
			} else {
				w.WriteHeader(http.StatusUnauthorized)
				w.Write([]byte("bad token"))
			}
		} else {
			w.WriteHeader(http.StatusUnauthorized)
			w.Write([]byte("entry is nil"))
		}
	}
}
}
